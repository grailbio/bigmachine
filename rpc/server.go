// Copyright 2018 GRAIL, Inc. All rights reserved.
// Use of this source code is governed by the Apache 2.0
// license that can be found in the LICENSE file.

// Package rpc implements a simple RPC system for Go methods. Rpc can
// dispatch methods on any Go value of the form:
//
//	Func(ctx context.Context, arg argType, reply *replyType) error
//
// By default, the values are Gob-encoded, with the following
// exceptions:
//	- if argType is io.Reader, a direct byte stream is provided
//	- if replyType is io.ReadCloser, a direct byte stream is provided
// In the future, the package will also support custom codecs, so
// that, for example, if the argument or reply is generated by a
// protocol buffer, then protocol buffer encoding is used
// automatically.
//
// Every value is registered with a name. This name is used by the
// client to specify the object on which to dispatch methods.
//
// Rpc uses HTTP as its transport protocol: the RPC server implements
// an HTTP handler, and exports an HTTP endpoint for each method that
// is served. Similarly, the RPC client composes a HTTP client and
// constructs the appropriate URLs on dispatch.
//
// Each method registered by a server receives its own URL endpoint:
// Service.Method. Calls to a method are performed as HTTP POST
// requests to that method's endpoint. The HTTP body contains a
// gob-encoded (package encoding/gob) stream of data interpreted as
// the method's argument. In the case where the method's argument is
// an io.Reader, the body instead passed through. The reply body
// contains the reply, also gob-encoded, except when the reply has
// type io.ReadCloser in which case the body is passed through and
// streamed end-to-end.
//
// On successful invocation, HTTP code 200 is returned. When a method
// invocation returns an error, HTTP code 590 is returned. In this
// case, the error message is gob-encoded as the reply body.
//
// At the moment, a new gob encoder is created for each call. This is
// inefficient for small requests and replies. Future work includes
// maintaining long-running gob codecs to avoid these inefficiences.
package rpc

import (
	"bytes"
	"context"
	"encoding/gob"
	"fmt"
	"io"
	"net/http"
	"path"
	"reflect"
	"runtime/debug"
	"strings"
	"sync"

	"github.com/grailbio/base/backgroundcontext"
	"github.com/grailbio/base/errors"
	"github.com/grailbio/base/log"
)

// MethodErrorCode is the HTTP error used for method errors.
// On method error, the error message is serialized by the server
// and should be reconstructed by the client.
const methodErrorCode = 590

// BigmachineErrorTrailer is the HTTP trailer used to
// indicate streaming errors.
const bigmachineErrorTrailer = "x-bigmachine-error"

var (
	typeOfContext    = reflect.TypeOf((*context.Context)(nil)).Elem()
	typeOfReader     = reflect.TypeOf((*io.Reader)(nil)).Elem()
	typeOfReadCloser = reflect.TypeOf((*io.ReadCloser)(nil)).Elem()
	typeOfError      = reflect.TypeOf((*error)(nil)).Elem()
)

// method represents a single method type
type method struct {
	method     reflect.Method
	arg, reply reflect.Type
}

// A service is a collection of methods invoked on the same receiver value.
type service struct {
	name    string
	recv    reflect.Value
	typ     reflect.Type
	methods map[string]*method
}

// Init initializes a service by inspecting its receiver for
// candidate methods (of the form described in the package docs).
func (s *service) Init() error {
	s.methods = make(map[string]*method)
	// Search for methods of the form:
	//	Func(context.Context, argType, *replyType) error
	//
	// TODO: special cases
	//	- ProtoMessage()
	//	- Vanadium structs?
	// TODO: provide better ergonomics here, e.g., report methods
	// that are almost RPC methods, but don't match one or two of
	// the criteria.
	for i := 0; i < s.typ.NumMethod(); i++ {
		m := s.typ.Method(i)
		// Not exported.
		if m.PkgPath != "" {
			continue
		}
		// Receiver, context, args, reply
		if m.Type.NumIn() != 4 {
			continue
		}
		if m.Type.In(1) != typeOfContext {
			continue
		}
		// TODO: m.Type(2): check that it's exported or builtin
		if m.Type.In(3).Kind() != reflect.Ptr {
			continue
		}
		if m.Type.NumOut() != 1 {
			continue
		}
		if m.Type.Out(0) != typeOfError {
			continue
		}
		s.methods[m.Name] = &method{
			method: m,
			arg:    m.Type.In(2),
			reply:  m.Type.In(3),
		}
	}
	return nil
}

// A Server dispatches methods on collection of registered objects.
// Its dispatch rules are described in the package docs. Server
// implements http.Handler and can be served by any HTTP server.
type Server struct {
	mu       sync.RWMutex
	services map[string]*service
}

// NewServer returns a new, initialized, Server.
func NewServer() *Server {
	return &Server{
		services: make(map[string]*service),
	}
}

// Register registers the provided interface under the given name.
// Exported and eligible methods on iface, according to the rules
// described in the package docs, are invoked by this server when
// calls are received from a client. A server dispatches methods
// concurrently.
//
// Register is a noop the a service with the provided name has already been
// registered.
func (s *Server) Register(serviceName string, iface interface{}) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.services[serviceName] != nil {
		log.Printf("service %s already defined", serviceName)
		return nil
	}
	svc := &service{
		recv: reflect.ValueOf(iface),
		typ:  reflect.TypeOf(iface),
		name: serviceName,
	}
	if err := svc.Init(); err != nil {
		return err
	}
	s.services[serviceName] = svc
	return nil
}

// ServeHTTP interprets an HTTP request and, if it represents a valid
// rpc call, dispatches it onto the appropriate registered method.
//
// ServeHTTP implements http.Handler.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "method not allowed", 405)
		return
	}
	ctx := backgroundcontext.Wrap(r.Context())
	parts := strings.SplitN(path.Base(r.URL.Path), ".", 2)
	if len(parts) != 2 {
		http.Error(w, "bad url", 400)
		return
	}
	service, method := parts[0], parts[1]
	s.mu.RLock()
	svc := s.services[service]
	s.mu.RUnlock()
	if svc == nil {
		http.Error(w, "no such service", 404)
		return
	}
	m := svc.methods[method]
	if m == nil {
		http.Error(w, "no such method", 404)
		return
	}
	defer r.Body.Close()
	var (
		err          error
		requestBytes = -1
		replyBytes   = -1
	)
	done := serverstats.Start("", service+"."+method)
	defer func() {
		done(int64(requestBytes), int64(replyBytes), err)
	}()
	// Read the request.
	var argv reflect.Value
	if m.arg == typeOfReader {
		// Readers get the body straight.
		argv = reflect.ValueOf(r.Body)
	} else {
		if m.arg.Kind() == reflect.Ptr {
			argv = reflect.New(m.arg.Elem())
		} else {
			argv = reflect.New(m.arg)
		}
		sizeReader := &sizeTrackingReader{Reader: r.Body}
		dec := gob.NewDecoder(sizeReader)
		requestBytes = sizeReader.Len()
		if err = dec.Decode(argv.Interface()); err != nil {
			http.Error(w, fmt.Sprintf("error decoding request: %v", err), 400)
			return
		}
		if m.arg.Kind() != reflect.Ptr {
			argv = argv.Elem()
		}
	}
	var (
		replyv     reflect.Value
		readcloser io.ReadCloser
	)
	if m.reply.Elem() == typeOfReadCloser {
		replyv = reflect.ValueOf(&readcloser)
	} else {
		replyv = reflect.New(m.reply.Elem())
		switch m.reply.Elem().Kind() {
		case reflect.Map:
			replyv.Elem().Set(reflect.MakeMap(m.reply.Elem()))
		case reflect.Slice:
			replyv.Elem().Set(reflect.MakeSlice(m.reply.Elem(), 0, 0))
		}
	}
	err = func() (err error) {
		defer func() {
			if e := recover(); e != nil {
				log.Error.Printf("panic in method call %s.%s\n%s", service, method, string(debug.Stack()))
				err = errors.E(errors.Fatal, fmt.Errorf("panic: %v", e))
			}
		}()
		rvs := m.method.Func.Call([]reflect.Value{svc.recv, reflect.ValueOf(ctx), argv, replyv})
		if e := rvs[0].Interface(); e != nil {
			err = e.(error)
		}
		return
	}()
	code := 200
	replyIface := replyv.Interface()
	if err != nil {
		code = methodErrorCode
		replyIface = errors.Recover(err)
	}
	if readcloser != nil {
		defer readcloser.Close()
		w.Header().Set("Content-Type", "application/octet-stream")
		// We pre-declare a trailer so that we can indicate if we encountered an error
		// while streaming.
		w.Header().Set("Trailer", bigmachineErrorTrailer)
		w.WriteHeader(code)
		var wr io.Writer = w
		if _, needFlush := readcloser.(*flushOpt); needFlush {
			if wf, ok := wr.(writeFlusher); ok {
				wr = &flusher{wf}
			} else {
				log.Printf("%s.%s: asked to flush, but HTTP connection does not support flushing", service, method)
			}
		}
		var errStr string
		if _, err = io.Copy(wr, readcloser); err != nil {
			log.Error.Printf("rpc: error writing reply: %v", err)
			errStr = err.Error()
		}
		// This is required because of a bug in net/http2 that causes the
		// connection to hang when pre-declared trailers are not set.
		w.Header().Set(bigmachineErrorTrailer, errStr)
		return
	}
	w.Header().Set("Content-Type", gobContentType)
	if code != 200 {
		// Only write error codes here so that, if the call is a success
		// but encoding fails, we have a chance to propagate the error
		// properly.
		w.WriteHeader(code)
	}
	b := new(bytes.Buffer)
	enc := gob.NewEncoder(b)
	err = enc.Encode(replyIface)
	replyBytes = b.Len()
	if err == nil {
		_, err = w.Write(b.Bytes())
	}
	if err != nil {
		log.Error.Printf("rpc: error writing reply: %v", err)
		// May not work, but it's worth a try:
		http.Error(w, fmt.Sprint(err), 500)
		return
	}
}

// Flush wraps the provided ReadCloser to instruct the rpc server to
// flush after every write. This is useful when the reply stream
// should be interactive -- no guarantees are otherwise provided
// about buffering.
func Flush(rc io.ReadCloser) io.ReadCloser {
	return &flushOpt{rc}
}

type flushOpt struct{ io.ReadCloser }

type writeFlusher interface {
	io.Writer
	http.Flusher
}

type flusher struct{ writeFlusher }

func (f *flusher) Write(p []byte) (n int, err error) {
	n, err = f.writeFlusher.Write(p)
	f.writeFlusher.Flush()
	return
}
